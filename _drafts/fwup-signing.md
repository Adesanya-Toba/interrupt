---
title: "Authenticate firmware builds with code signing"
description: WIP
author: francois
---

<!-- excerpt start -->
<!-- excerpt end -->

{% include newsletter.html %}
{% include toc.html %}

## Firmware Signing Explained

### What is code signing

Code signing is a method of proving a file was created by a trusted source and
has not been tampered with. This is achieved by creating a signature for the
file: a token which can be verified but not forged.

We all use signatures in our day to day life, by scribbling our name at the
bottom of our credit card receipts, contracts, and bank checks. These signatures
can be verified quite easily by comparing them to previous signatures, but are
hard to forge because they rely on an individual's muscle memory.

Code signing uses cryptographic algorithms to achieve a similar goal. The
resulting signatures can only be generated by people who know a given password,
also known as a secret key, but can be verified as genuine by anyone.

Additionally, the signatures are tied to a given firmware binary so should the
binary change by so much as 1 bit the signature would no longer be valid.

### Why sign our firmware

By implementing signature verification in our bootloader we can identify
whether or not a given firmware update was provided by the manufacturer, or if
it has been tempered with. The bootloader can then decide to either warn the
user, void the device's warranty, or simply refuse to run the unauthenticated
binary.

With more and more devices connected to the internet, security is an
increasingly hot topic in firmware development. A device which accepts firmware
updates over the wireless or internet connectivity but does not verify it opens
itself to compromise. By feeding it with a malicious firmware image, attacker
might:
* Brick the device, or the whole fleet
* Snoop on end users and compromise their privacy and security
* Strategically malfunction at a critical time

These are highly undesirable outcome, which can be effected at scale due to the
internet of things. In 2020, it is reckless to implement firmware update for our
systems without some form of authentication.

> **What signing is not**: code signing is an important component of firmware
> security, it is not by itself sufficient to build secure systems. Secure
> coding, static analysis, hardware tamper detection, JTAG locking, and many
> more techniques should be implemented as well.
> Code signing also does nothing to protect against reverse engineering. It is a
> distinct technique from firmware encryption.

### ECDSA

Several algorithms can be used to sign firmware, including RSA, DSA, and ECDSA.
In this post, we focus on ECDSA for a few reason:

1. Security: ECDSA is the latest and greatest in terms of signature algorithms.
   While standard DSA is considered broken by most, ECDSA is expected to remain
secure until quantum computing becomes widely available.
2. Popularity: ECDSA is used extensively in applications ranging from
   cryptocurrencies (bitcoin) to secure messaging. With popularity comes battle
tested implementations and credibility.
3. Availability: Open source implementations of ECDSA are available for
   microcontrollers, including mbedtls[^mbedtls], wolfssl[^wolfssl], and
micro-ecc.
4. Small Footprint: ECDSA implementations are very small (single digit kB), and
   require smaller keys than RSA or DSA for similar levels of security. This
saves both code space and RAM and makes ECDSA well suited to embedded
environments.

Understanding the math behind ECDSA is outside of the scope of this article, but
here is a high level overview of how the process works: 
1. A cryptographic hash of the firmware  binary is created. Any cryptographic
   hashing algorithm should work, though SHA-2 family hashes are recommended. In
the case of SHA-256, this yields a 32-byte number.
2. A signature is generated using a private key and the cryptographic hash.
   This signature is distributed alongside the firmware and a public key. The
signature may not be deterministic, so don't fret if multiple invocations of
your ECDSA code yield different signatures. This signature is a pair of
integers, each 32 bytes long.
3. To verify the binary, a SHA-256 hash is once again computed for our firmware
   binary.
4. The public key and the hash can be used to verify the signature was generated
   using matching inputs.

### Setup

Like we did in previous post, we use [Renode]({% post_url
2020-03-23-intro-to-renode %}) to run the examples in this post. Our previous
[firmware update post]({% post_url 2020-06-23-device-firmware-update-cookbook
%}) contains detailed instructions. In short:

```
# Clone the repository & navigate to the example
$ git clone https://github.com/memfault/interrupt.git
$ cd examples/fwup-signing

# Build project and start Renode
$ make && ./start.sh
```

One change we did make from previous posts is run in headless mode. This is done
by invoking Renode with the following flags:

```
mono64 $RENODE_EXE_PATH renode-config.resc --port 4444 --disable-xwt
```

We can then use telnet to connect to the renode console:

```
$ telnet localhost 4444
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Renode, version 1.9.0.28660 (cd1a61a4-202006301553)

(monitor) i $CWD/renode-config.resc
(STM32F429) start
Starting emulation...
(STM32F429) q
Renode is quitting
```

Similarly, we route the device UART to a telnet port rather than a graphical
window by adding two lines to our `renode-config.resc`:

```
emulation CreateServerSocketTerminal 4445 "externalUART"
connector Connect sysbus.uart2 externalUART
```

We can then access our emulated device's UART via telnet as well:

```
$ telnet localhost 4445
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Bootloader started
Valid public key
Invalid signature
Booting slot 1
Shared memory uinitialized, setting magic
Loader STARTED - version 1.0.0 (4015f0a)
Booting slot 2
App STARTED - version 1.0.1 (4015f0a) - CRC 0x1b11019d
```

### Architecture

As a reminder, this is what our device firmware update architecture looks like:

<style>
.diag4 {
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
}
</style>
{% blockdiag size:120x40 %}
blockdiag {
    span_width = 100;
    // Set labels to nodes.
    C [label = "Bootloader"];
    A [label = "App Loader"];
    B [label = "Application"];
    C -> A [label = "Loads", fontsize=8];
    A -> B [label = "Ld, Updt", fontsize=8];

    E [label = "Updater"];
    A -> E [label = "Ld, Updt", fontsize=8];
    E -> A [label = "Updates", fontsize=8];
    C -> E [label = "Loads", style=dashed, fontsize=8];

    group {
        label = "Slot 0";
        color = "PaleGreen";
        C;
    }
    group {
        label = "Slot 1";
        color = "LightPink";
        A;
    }
    group {
        label = "Slot 2";
        color = "LemonChiffon";
        B; E;
    }
}
{% endblockdiag %}{:.diag4}

With the following functionality for each block:

1. Bootloader: a simple program whose sole job is to load the Loader, and fallback
   to another image if the Loader is invalid.
2. Loader: a program that can verify our Application image, load it, and update
   it.
3. Application: our main code, which does not do any updates itself
4. Updater: a program that temporarily replaces the Application and can update
   the Loader.

The Loader, the Application, and the Updater all need to be signed since they
can be updated. Components that updates other components need to implement our
signature verification algorithm, in our case that's the Loader and the Updater.

### Generating public/private key pairs

Before we can begin, we must generate a pair of keys. Our **private key** also
known as **signing key** is used to create the signatures, and should be kept
private. Anyone with access to the key will be able to sign firmware on your
behalf. Our **public key** also known as **validation key** is used to verify
signature. It can be freely distributed.

Several tools can be used to generate our key pair but the simplest is
`openssl`, a cross platform cryptography tools.

First, we generate our private key:
```
$ openssl ecparam -name secp256k1 -genkey -noout -out private.pem
```

Then we create a public key to go with this private key:
```
$ openssl ec -in private.pem -pubout -out public.pem
```

At this point we should have two files: `public.pem` and `private.pem`.

We can test the sign/verify flow with openssl as well. To sign a file we do:

```
$ openssl dgst -sha256 -sign private.pem -out build/fwup-example.bin.sig build/fwup-example.bin
```

Where "fwup-example.bin" is the file we want to sign, and "fwup-example.bin.sig"
is the signature file we want to create.

The signature can then be verified with:

```
$ openssl dgst -sha256 -sign private.pem -out build/fwup-example.bin.sig build/fwup-example.bin
Verified OK
```

That's it! We've got keys we can use to sign and verify firmware builds!

### Bundling signatures with our builds

Next we must add the signing step to our build and add the signatures to our
image. The latter is easy to do: we already have a metadata for our images saved
into the `image_hdr_t`. We simply add a field for the signature and increment
our metadata version:

```diff
 typedef enum {
     IMAGE_VERSION_1 = 1,
-    IMAGE_VERSION_CURRENT = IMAGE_VERSION_1,
+    IMAGE_VERSION_2 = 2,
+    IMAGE_VERSION_CURRENT = IMAGE_VERSION_2,
 } image_version_t;

 typedef struct __attribute__((packed)) {
@@ -34,10 +35,13 @@
     uint32_t vector_addr;
     uint32_t reserved;
     char git_sha[8];
+    uint8_t ecdsa_sig[64];
 } image_hdr_t;
```

The 64 bytes contain the two integers that make up our signature one after the
other.

We then modify `patch_image_header.py` so that it generates and appends the
signature to our binary. Rather than shell out to `openssl`, we use a native
Python library that implements ECDSA. Simply enough, it is called `ecdsa`.

Generating the signature can be accomplished with a few lines of code:

```python
import hashlib
from ecdsa import SigningKey
from ecdsa.util import sigencode_string
from binascii import hexlify


def gen_binary_signature(data, key_filename):
    with open(key_filename, "r") as f:
        key_pem = f.read()
    key = SigningKey.from_pem(key_pem)
    sig = key.sign_deterministic(data, hashfunc=hashlib.sha256, sigencode=sigencode_string)
    return sig
```

A few things to note:
1. We use SHA-256 as our hashing function, so we must specify it when we
   generate the signature
2. The `sigencode` parameter is used to specify the format of the signature. By
   default, a DER file a generated (this is what openssl uses as well), but by
using `sigencode_string` we tell the library to generate a flat string that
contains the binary representation of both signature integers one after another.
This is a simpler format and will save us from implementing a DER parser in
our firmware.

We then update our `patch_binary_payload` function to invoke
`gen_binary_signature`:

```diff
+def patch_binary_payload(bin_filename, pk_filename):
     """
     Patch crc & data_size fields of image_hdr_t in place in binary

     Raise exception if binary is not a supported type
     """
-    IMAGE_HDR_SIZE_BYTES = 32
+    IMAGE_HDR_SIZE_BYTES = 96
     IMAGE_HDR_MAGIC = 0xCAFE
-    IMAGE_HDR_VERSION = 1
+    IMAGE_HDR_VERSION = 2

     with open(bin_filename, "rb") as f:
         image_hdr = f.read(IMAGE_HDR_SIZE_BYTES)
@@ -35,6 +47,7 @@

     data_size = len(data)
     crc32 = binascii.crc32(data) & 0xffffffff
+    signature = gen_binary_signature(data, 'private.pem')

     image_hdr_crc_data_size = struct.pack("<LL", crc32, data_size)
     print(
@@ -42,11 +55,17 @@
             crc32, data_size, bin_filename
         )
     )
+
     with open(bin_filename, "r+b") as f:
         # Seek to beginning of "uint32_t crc"
         f.seek(4)
         # Write correct values into crc & data_size
         f.write(image_hdr_crc_data_size)
+        # Seek to beginning of signature
+        f.seek(32)
+        # Write the signature in place
+        f.write(signature)


 if __name__ == "__main__":
@@ -54,6 +73,7 @@
         description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter,
     )
     parser.add_argument("bin", action="store")
+    parser.add_argument("pk", action="store")
     args = parser.parse_args()

-    patch_binary_payload(args.bin)
+    patch_binary_payload(args.bin, args.pk)
```

Since the script now takes an argument, we must modify our Makefile as well

```diff
-$(BUILD_DIR)/$(PROJECT)-%.bin: $(BUILD_DIR)/$(PROJECT)-%.elf
+$(BUILD_DIR)/$(PROJECT)-%.bin: $(BUILD_DIR)/$(PROJECT)-%.elf $(PK_PEM_PATH)
        $(ECHO) "  OBJCOPY      $@"
-       $(Q)$(OCPY) $^ $@ -O binary
+       $(Q)$(OCPY) $< $@ -O binary
        $(ECHO) "  PATCH_IMAGE  $@"
-       $(Q)$(PYTHON) patch_image_header.py $@ > /dev/null
+       $(Q)$(PYTHON) patch_image_header.py $@ $(PK_PEM_PATH) > /dev/null
```

Where `PK_PEM_PATH` is the path to your private key.<!-- TODO: Add a note about
security -->

We now have a build process that generates signed binaries!

### Verifying signatures in our Loader

Now that our firmware builds are signed, lets verify those signatures in our
Loader!

Remember that the process takes two steps:
1. Compute the SHA-256 hash of our firmware binary
2. Verify the signature with the hash and the public key

First, we'll need an implementation of the ECDSA algorithm. Remember, the first
rule of crypto is "don't roll your own crypto" so you'll want a battle-tested
library implemented by experts. There are a few good options, but we chose
micro-ecc[^micro-ecc] as we are most familiar with it and it is extremely small.

micro-ecc is extremely easy to add to a project: it consists of a single
`.c` (uECC.c) and a single `.h` (uECC.h) file. Add the source file to your list of sources, and
the header file to your include path.

We then add our public key to our firmware. micro-ecc expects our keys to be
"represented in standard format, but without the 0x04
prefix"[^micro-ecc-representation]. We can use `openssl` to get the raw key
data:

```shell
(.venv) $ openssl ec -in private.pem -text -noout
read EC key
Private-Key: (256 bit)
priv:
    4f:93:5d:53:41:82:21:91:11:e9:fe:9f:33:90:09:
    28:da:d0:96:70:f7:5e:26:85:dc:ff:5d:bc:f8:6f:
    5f:15
pub:
    04:d0:e6:a7:a5:4e:33:0e:bb:d9:9e:e6:8f:59:ff:
    b6:c1:19:76:28:60:88:16:6a:17:8b:7b:e0:66:cf:
    7b:71:0d:f5:cc:95:76:22:ae:0e:a4:ef:49:bd:07:
    2a:71:49:84:49:78:eb:34:e5:78:b3:a7:96:48:89:
    7c:4f:d1:7e:a5
ASN1 OID: secp256k1
```

We take the `pub` section, remove the leading `04` bytes, and translate it to a
C array:

```c
static const uint8_t PUBKEY[] = {
  0xd0, 0xe6, 0xa7, 0xa5, 0x4e, 0x33, 0x0e, 0xbb, 0xd9, 0x9e, 0xe6, 0x8f, 0x59,
  0xff, 0xb6, 0xc1, 0x19, 0x76, 0x28, 0x60, 0x88, 0x16, 0x6a, 0x17, 0x8b, 0x7b,
  0xe0, 0x66, 0xcf, 0x7b, 0x71, 0x0d, 0xf5, 0xcc, 0x95, 0x76, 0x22, 0xae, 0x0e,
  0xa4, 0xef, 0x49, 0xbd, 0x07, 0x2a, 0x71, 0x49, 0x84, 0x49, 0x78, 0xeb, 0x34,
  0xe5, 0x78, 0xb3, 0xa7, 0x96, 0x48, 0x89, 0x7c, 0x4f, 0xd1, 0x7e, 0xa5
  // 64 bytes
};
```

We can then verify that uECC is able to read the key correctly by calling
`uECC_valid_public_key`:

```c
#include <micro-ecc/uECC.h>

const struct uECC_Curve_t *curve = uECC_secp256k1();
if (!uECC_valid_public_key(PUBKEY, curve)) {
    printf("Public key is NOT valid\n");
} else {
    printf("Public key is valid\n");
}
```

Note that we had to select the same curve we used to generate the key, here
`secp2561k`.

### A note on threat models



## Additional Considerations

### Hardware Crypto Blocks

### Flash Locking

### Key Storage

### Development Keys

### Key Rotation

## Closing

<!-- Interrupt Keep START -->

{% include newsletter.html %}

{% include submit-pr.html %}

<!-- Interrupt Keep END -->

{:.no_toc}

## References


